{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"proyecto%20final2/","title":"\ud83d\udcda PROYECTO FINAL - ELEMENTOS PROGRAMABLES II","text":""},{"location":"proyecto%20final2/#1-resumen","title":"1) Resum\u00e9n  \ud83d\udccc","text":"<p>El programa implementa una plataforma Stewart controlada por gestos de la mano mediante visi\u00f3n por computadora. Utiliza MediaPipe para detectar los landmarks de la mano (mu\u00f1eca, dedo medio y pulgar) y calcula dos par\u00e1metros principales: el pitch (inclinaci\u00f3n arriba/abajo) basado en la profundidad Z entre mu\u00f1eca y dedo medio, y el roll (inclinaci\u00f3n izquierda/derecha) determinado por la posici\u00f3n vertical del pulgar. Estos valores se procesan con un filtro exponencial para eliminar tembladera y se env\u00edan v\u00eda Bluetooth Classic a un ESP32, que controla 3 servomotores MG90S en configuraci\u00f3n triangular (pines 4, 5 y 15). El ESP32 recibe comandos en formato A1:x,A2:y,A3:z y genera se\u00f1ales PWM a 50Hz con resoluci\u00f3n de 12 bits para posicionar cada servo. Refuerza conceptos de procesamiento de imagen en tiempo real, comunicaci\u00f3n serial inal\u00e1mbrica, control de actuadores y cinem\u00e1tica inversa b\u00e1sica para plataformas de movimiento. </p> <p>## 1) Datos \ud83d\udccc</p> <ul> <li>Equipo / Autor(es): Ximena Guadalupe Verdi Toledo</li> <li>Curso / Asignatura: Elementos Programables II  </li> <li>Fecha: 07/12/25  </li> </ul>"},{"location":"proyecto%20final2/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: _ Desarrollar un sistema de control para una plataforma Stewart de 3 grados de libertad mediante el reconocimiento de gestos de la mano utilizando visi\u00f3n por computadora y comunicaci\u00f3n inal\u00e1mbrica Bluetooth._</li> <li>Espec\u00edficos:</li> <li>OP1\u2026 Implementar la detecci\u00f3n de la mano en tiempo real utilizando la librer\u00eda MediaPipe para obtener los landmarks de mu\u00f1eca, dedo medio y pulgar</li> <li>OP2\u2026 Calcular los par\u00e1metros de inclinaci\u00f3n (pitch y roll) a partir de las posiciones relativas de los puntos de la mano y aplicar filtros para suavizar el movimiento.</li> <li>OP3\u2026 Establecer comunicaci\u00f3n Bluetooth entre Python y el ESP32 para transmitir los \u00e1ngulos calculados de forma inal\u00e1mbrica.</li> <li>OP4\u2026 Controlar 3 servomotores MG90S mediante se\u00f1ales PWM generadas por el ESP32 para inclinar la plataforma seg\u00fan los gestos detectados.</li> </ul>"},{"location":"proyecto%20final2/#2-instalacion","title":"2) Instalaci\u00f3n","text":"<ul> <li>Seguir el siguiente link, para poder realizar el c\u00f3digo: https://iberopuebla.sharepoint.com/:p:/s/Section_11192A-O25/Eagdi_tzhWZMgKc8luT4Fi0BwHxjPm1VrXFUaZsVAG4fsw?e=HB032a</li> </ul>"},{"location":"proyecto%20final2/#2-requisitos","title":"2) Requisitos","text":"<p>HARDWARE - ESP32-D - SERVOMOTORES MG90S - PROTOBOARD - CABLES DUPONT (macho-macho, macho-hembra) - FUENTE DE ALIMENTACI\u00d3N (6v para los servos) - C\u00c1MARA WEB O CAMARA INTEGRADA DE LAPTOP - ESTRUCTURA DE PLATAFORMA STEWART IMPRESA EN 3D</p> <p>SOFTWARE) - ARDUINO IDE (para programar ESP32-D) - VISUAL STUDIO CODE (python) - LIBRERIAS DE PYTHON</p> <p>CONOCIMIENTOS PREVIOS - PROGRAMACI\u00d3N EN Python - PROGRAMACI\u00d3N EN C++(arduino) - COMUNICACI\u00d3N SERIAL Y BLUETOOTH - CONTROL DE SERVOMOTORES CON PWM - _ELECTR\u00d3NICA B\u00c1SICA _</p>"},{"location":"proyecto%20final2/#2-piezas-a-utilizar","title":"2) PIEZAS A UTILIZAR \u2328","text":"<ul> <li>La pieza mostrada corresponde a la base central del proyecto.Su geometr\u00eda se compone de un contenedor con forma poligonal, con paredes altas que brindan rigidez estructural y evitan la deformaci\u00f3n durante el movimiento. En su periferia integra tres soportes elevados con huecos de montaje, los cuales permiten fijar servomotores de rotaci\u00f3n.</li> </ul> <ul> <li>Esta pieza funciona como v\u00ednculo mec\u00e1nico entre el servomotor y la base. Su forma alargada permite transmitir el movimiento generado por el servo hacia la estructura central. Cuenta con dos orificios de uni\u00f3n: uno con forma ovalada, que facilita el acoplamiento y reduce fricci\u00f3n con el eje del servo, y otro circular, destinado a la conexi\u00f3n mediante tornillo con la base.</li> </ul> <ul> <li>Esta pieza corresponde al brazo principal de soporte, encargado de conectar la parte superior del sistema con los servomotores. Su geometr\u00eda alargada proporciona mayor alcance y movimiento, permitiendo que la plataforma superior cambie de inclinaci\u00f3n. El brazo incluye dos orificios en los extremos, usados como puntos de articulaci\u00f3n con tornillos. Adem\u00e1s, cuenta con una ranura longitudinal, que facilita el montaje del tornillo.</li> </ul>"},{"location":"proyecto%20final2/#3-codigo","title":"3) C\u00f3digo \u2328\ufe0f","text":""},{"location":"proyecto%20final2/#codigo-python-visual-studio","title":"C\u00d3DIGO PYTHON (Visual Studio)","text":"<pre><code># ============================================================================\n# PLATAFORMA STEWART - CONTROL POR GESTOS DE MANO\n# ============================================================================\n# Este programa utiliza visi\u00f3n por computadora para detectar la posici\u00f3n\n# y orientaci\u00f3n de la mano del usuario, calculando \u00e1ngulos que se env\u00edan\n# a un ESP32 v\u00eda Bluetooth para controlar 3 servomotores en una plataforma\n# Stewart de 3 grados de libertad.\n# ============================================================================\n\n# ----- IMPORTACI\u00d3N DE LIBRER\u00cdAS -----\nimport cv2              # OpenCV: procesamiento de im\u00e1genes y captura de video\nimport mediapipe as mp  # MediaPipe: detecci\u00f3n de landmarks de la mano\nimport time             # Control de tiempos y delays\nimport bluetooth        # PyBluez: comunicaci\u00f3n Bluetooth con ESP32\n\n# ============================================================================\n# CONFIGURACI\u00d3N DE CONEXI\u00d3N BLUETOOTH\n# ============================================================================\n# El ESP32 act\u00faa como servidor Bluetooth Serial (SPP - Serial Port Profile)\n# La comunicaci\u00f3n se realiza en el puerto 1, que es el est\u00e1ndar para SPP\n\nPORT = 1                          # Puerto Bluetooth est\u00e1ndar para SPP\nESP32_MAC = \"14:33:5C:02:4D:2A\"   # Direcci\u00f3n MAC del ESP32 (CAMBIAR seg\u00fan tu dispositivo)\n\n# Creaci\u00f3n del socket Bluetooth tipo RFCOMM (comunicaci\u00f3n serial)\nsock = bluetooth.BluetoothSocket()\nsock.settimeout(20)  # Timeout de 20 segundos para evitar bloqueos indefinidos\n\n# ----- BUCLE DE CONEXI\u00d3N -----\n# Intenta conectar continuamente hasta lograr la conexi\u00f3n\n# Esto es \u00fatil cuando el ESP32 tarda en estar disponible\nprint(\"Intentando conectar al ESP32...\")\nwhile True:\n    try:\n        sock.connect((ESP32_MAC, PORT))  # Intenta establecer conexi\u00f3n\n        print(\"\u00a1Conectado al ESP32!\")\n        break  # Sale del bucle si la conexi\u00f3n es exitosa\n    except Exception as e:\n        print(\"Error en conexi\u00f3n... reintentando:\", e)\n        time.sleep(1)  # Espera 1 segundo antes de reintentar\n\n# ----- FUNCI\u00d3N DE ENV\u00cdO DE DATOS -----\ndef send_bt(message: str):\n    \"\"\"\n    Env\u00eda un mensaje codificado en UTF-8 al ESP32 v\u00eda Bluetooth.\n\n    Par\u00e1metros:\n        message (str): Cadena de texto a enviar (ej: \"ANG:90,90,90\\n\")\n\n    El mensaje se codifica a bytes antes de enviarse ya que Bluetooth\n    trabaja con datos binarios, no strings directamente.\n    \"\"\"\n    try:\n        sock.send(message.encode())       # Codifica string a bytes y env\u00eda\n        print(\"Enviado:\", message.strip()) # Muestra en consola (sin salto de l\u00ednea)\n    except:\n        print(\"Error enviando datos\")      # Manejo b\u00e1sico de errores\n\n# ============================================================================\n# CONFIGURACI\u00d3N DE MEDIAPIPE HANDS\n# ============================================================================\n# MediaPipe Hands es un modelo de ML que detecta 21 puntos (landmarks)\n# en la mano, permitiendo rastrear su posici\u00f3n y orientaci\u00f3n en tiempo real\n\nmp_hands = mp.solutions.hands  # M\u00f3dulo de detecci\u00f3n de manos\n\n# Inicializaci\u00f3n del detector de manos con par\u00e1metros optimizados\nhands = mp_hands.Hands(\n    max_num_hands=1,              # Solo detectar 1 mano (mejor rendimiento)\n    min_detection_confidence=0.6, # Confianza m\u00ednima para detectar mano (60%)\n    min_tracking_confidence=0.5   # Confianza m\u00ednima para rastrear (50%)\n)\n\n# Utilidades para dibujar los landmarks en la imagen\nmp_draw = mp.solutions.drawing_utils\n\n# ----- CAPTURA DE VIDEO -----\ncap = cv2.VideoCapture(0)  # Abre la c\u00e1mara por defecto (\u00edndice 0)\n\n# ============================================================================\n# VARIABLES DE FILTRADO Y CONTROL\n# ============================================================================\n# Los filtros suavizan el movimiento, eliminando tembladera y ruido\n# Se utiliza un filtro exponencial de primer orden (EMA)\n\npitch_filtrado = 0  # Valor filtrado de inclinaci\u00f3n arriba/abajo\nroll_filtrado = 0   # Valor filtrado de inclinaci\u00f3n izquierda/derecha\nalpha = 0.25        # Factor de suavizado (0.1=muy suave, 1.0=sin filtro)\n\n# Control de frecuencia de env\u00edo\nultimo_envio = time.time()  # Timestamp del \u00faltimo env\u00edo\nintervalo_envio = 0.05      # Enviar cada 50ms (20 Hz)\n\n# ============================================================================\n# POSICIONES HOME (NEUTRAS)\n# ============================================================================\n# Cuando la mano est\u00e1 en posici\u00f3n neutral, los servos van a estos \u00e1ngulos\n# 90\u00b0 es el centro del rango de movimiento de un servo (0\u00b0-180\u00b0)\n\nHOME_IZQ = 90     # Posici\u00f3n home del servo izquierdo (Pin 15)\nHOME_ARRIBA = 90  # Posici\u00f3n home del servo central (Pin 33)\nHOME_DER = 90     # Posici\u00f3n home del servo derecho (Pin 25)\n\n# ============================================================================\n# GANANCIAS DE CONTROL\n# ============================================================================\n# Estas constantes determinan qu\u00e9 tan sensible es cada movimiento\n# Valores m\u00e1s altos = movimientos m\u00e1s amplios de los servos\n\nK_pitch = 30.0       # Sensibilidad para inclinaci\u00f3n arriba/abajo\nK_roll = 0.05        # Sensibilidad para detecci\u00f3n de roll (pulgar)\nK_lat = 85.0         # Sensibilidad para movimiento lateral (izq/der)\nK_mid_acompa = 20.0  # Cu\u00e1nto acompa\u00f1a el servo central al movimiento lateral\n\n# ============================================================================\n# BUCLE PRINCIPAL DE PROCESAMIENTO\n# ============================================================================\n# Este bucle se ejecuta continuamente mientras la c\u00e1mara est\u00e9 abierta,\n# capturando frames, proces\u00e1ndolos y enviando comandos al ESP32\n\nwhile cap.isOpened():\n    # ----- CAPTURA DE FRAME -----\n    ret, img = cap.read()  # Lee un frame de la c\u00e1mara\n    if not ret:\n        break  # Sale si no puede leer (c\u00e1mara desconectada)\n\n    # Espeja la imagen horizontalmente para efecto espejo natural\n    # Esto hace que el movimiento de la mano corresponda intuitivamente\n    img = cv2.flip(img, 1)\n\n    # Convierte de BGR (formato OpenCV) a RGB (formato MediaPipe)\n    rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\n    # ----- DETECCI\u00d3N DE MANO -----\n    results = hands.process(rgb)  # Procesa el frame con MediaPipe\n\n    h, w, _ = img.shape  # Obtiene dimensiones del frame (alto, ancho)\n    detectada = False    # Flag para saber si se detect\u00f3 mano\n\n    # ----- PROCESAMIENTO SI HAY MANO DETECTADA -----\n    if results.multi_hand_landmarks:\n        for hand in results.multi_hand_landmarks:\n            detectada = True\n\n            # Dibuja los 21 landmarks y sus conexiones en la imagen\n            mp_draw.draw_landmarks(img, hand, mp_hands.HAND_CONNECTIONS)\n\n            # ========== EXTRACCI\u00d3N DE LANDMARKS CLAVE ==========\n            # MediaPipe detecta 21 puntos en la mano, numerados del 0 al 20\n            # Usamos solo 3 puntos estrat\u00e9gicos:\n\n            muneca = hand.landmark[0]   # Punto 0: Mu\u00f1eca (base de la mano)\n            medio = hand.landmark[12]   # Punto 12: Punta del dedo medio\n            pulgar = hand.landmark[4]   # Punto 4: Punta del pulgar\n\n            # Convierte coordenadas normalizadas (0-1) a p\u00edxeles\n            # Las coordenadas de MediaPipe est\u00e1n normalizadas al tama\u00f1o de imagen\n            wx, wy = int(muneca.x * w), int(muneca.y * h)  # Mu\u00f1eca en p\u00edxeles\n            mx, my = int(medio.x * w), int(medio.y * h)    # Dedo medio en p\u00edxeles\n            px, py = int(pulgar.x * w), int(pulgar.y * h)  # Pulgar en p\u00edxeles\n\n            # Dibuja c\u00edrculos en los puntos clave para visualizaci\u00f3n\n            cv2.circle(img, (wx, wy), 10, (255, 0, 0), -1)  # Mu\u00f1eca: Azul\n            cv2.circle(img, (mx, my), 10, (0, 255, 0), -1)  # Medio: Verde\n            cv2.circle(img, (px, py), 10, (0, 0, 255), -1)  # Pulgar: Rojo\n\n            # ========== C\u00c1LCULO DE PITCH (ARRIBA/ABAJO) ==========\n            # El pitch se calcula usando la coordenada Z (profundidad)\n            # Cuando la mano se inclina hacia arriba, el dedo medio se acerca\n            # a la c\u00e1mara (Z menor) respecto a la mu\u00f1eca\n\n            pitch = (muneca.z - medio.z) * 1.8  # Diferencia de profundidad escalada\n            pitch = max(-1, min(1, pitch))       # Limita al rango [-1, 1]\n\n            # ========== C\u00c1LCULO DE ROLL (IZQUIERDA/DERECHA) ==========\n            # El roll se detecta por la posici\u00f3n vertical del pulgar\n            # Pulgar ARRIBA (py &lt; wy) = Roll positivo = Mover a DERECHA\n            # Pulgar ABAJO (py &gt; wy) = Roll negativo = Mover a IZQUIERDA\n\n            dy = wy - py              # Diferencia vertical (mu\u00f1eca - pulgar)\n            roll = dy * K_roll        # Escala la diferencia\n            roll = max(-1, min(1, roll))  # Limita al rango [-1, 1]\n\n            # ========== APLICACI\u00d3N DE FILTRO EXPONENCIAL ==========\n            # El filtro EMA (Exponential Moving Average) suaviza los valores\n            # F\u00f3rmula: valor_nuevo = (1-alpha)*valor_anterior + alpha*valor_actual\n            # Alpha bajo = m\u00e1s suave pero m\u00e1s lento\n            # Alpha alto = m\u00e1s r\u00e1pido pero m\u00e1s ruidoso\n\n            pitch_filtrado = (1 - alpha) * pitch_filtrado + alpha * pitch\n            roll_filtrado = (1 - alpha) * roll_filtrado + alpha * roll\n\n            # Zona muerta: ignora valores muy peque\u00f1os para evitar temblor\n            if abs(pitch_filtrado) &lt; 0.05:\n                pitch_filtrado = 0\n            if abs(roll_filtrado) &lt; 0.05:\n                roll_filtrado = 0\n\n            # ========== C\u00c1LCULO DE \u00c1NGULOS DE SERVOS ==========\n            # Cada servo se calcula bas\u00e1ndose en los valores filtrados\n            # La l\u00f3gica implementa el comportamiento de la plataforma Stewart\n\n            # ----- SERVO CENTRAL (ARRIBA - Pin 33) -----\n            # Sube con pitch positivo (mano hacia arriba)\n            # Tambi\u00e9n sube ligeramente cuando hay movimiento lateral\n            a_arriba = HOME_ARRIBA + K_pitch * pitch_filtrado + K_mid_acompa * abs(roll_filtrado)\n\n            # ----- SERVOS LATERALES (IZQ Pin 15, DER Pin 25) -----\n            # Calculamos el delta lateral basado en el roll\n            delta_lat = K_lat * roll_filtrado\n\n            # Izquierdo y derecho se mueven en direcciones opuestas\n            # Roll positivo (pulgar arriba/derecha): izq baja, der sube\n            # Roll negativo (pulgar abajo/izquierda): izq sube, der baja\n            a_izq = HOME_IZQ - delta_lat\n            a_der = HOME_DER + delta_lat\n\n            # Acompa\u00f1amiento de pitch en servos laterales\n            # Ambos bajan cuando la mano sube (pitch positivo)\n            a_izq += (K_pitch * 0.25) * pitch_filtrado\n            a_der += (K_pitch * 0.25) * pitch_filtrado\n\n            # Limita los \u00e1ngulos al rango v\u00e1lido de los servos (0\u00b0-180\u00b0)\n            a_izq = int(max(0, min(180, a_izq)))\n            a_arriba = int(max(0, min(180, a_arriba)))\n            a_der = int(max(0, min(180, a_der)))\n\n            # ========== ENV\u00cdO DE DATOS AL ESP32 ==========\n            # Solo env\u00eda si ha pasado suficiente tiempo desde el \u00faltimo env\u00edo\n            # Esto evita saturar la comunicaci\u00f3n Bluetooth\n\n            if time.time() - ultimo_envio &gt;= intervalo_envio:\n                # Formato del mensaje: \"ANG:izq,arriba,der\\n\"\n                msg = f\"ANG:{a_izq},{a_arriba},{a_der}\\n\"\n                send_bt(msg)\n                ultimo_envio = time.time()\n\n    # ----- MENSAJE CUANDO NO SE DETECTA MANO -----\n    if not detectada:\n        cv2.putText(img, \"No se detecta mano\", (10, 30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)\n\n    # ----- MOSTRAR IMAGEN EN VENTANA -----\n    cv2.imshow(\"STEWART CONTROL PULGAR\", img)\n\n    # ----- CONTROL DE TECLADO -----\n    k = cv2.waitKey(1)  # Espera 1ms por tecla\n\n    if k == ord('q'):      # Tecla 'q': Salir del programa\n        break\n    if k == ord('z') or k == ord('c'):  # Tecla 'z' o 'c': Enviar comando ZERO\n        send_bt(\"ZERO\\n\")   # Lleva todos los servos a posici\u00f3n home\n\n# ============================================================================\n# LIMPIEZA Y CIERRE\n# ============================================================================\n# Libera todos los recursos antes de terminar\n\nsock.close()              # Cierra la conexi\u00f3n Bluetooth\ncap.release()             # Libera la c\u00e1mara\ncv2.destroyAllWindows()   # Cierra todas las ventanas de OpenCV\nprint(\"Programa terminado\")\n</code></pre>"},{"location":"proyecto%20final2/#codigo-c-arduino","title":"C\u00d3DIGO C++ (ARDUINO)","text":"<pre><code>// ============================================================================\n// PLATAFORMA STEWART - FIRMWARE ESP32\n// ============================================================================\n\n#include &lt;Arduino.h&gt;           // Librer\u00eda base de Arduino\n#include \"BluetoothSerial.h\"   // Librer\u00eda para Bluetooth Classic (SPP)\n\n// Instancia del objeto Bluetooth Serial\nBluetoothSerial SerialBT;\n\n// Almacena caracteres recibidos hasta formar un comando completo (terminado en '\\n')\nString btBuffer;\n\n#define SERVO_IZQ    15   // GPIO 15: Servo izquierdo\n#define SERVO_ARRIBA 33   // GPIO 33: Servo central/vertical\n#define SERVO_DER    25   // GPIO 25: Servo derecho\n\n// ============================================================================\n// \u00c1NGULOS HOME (POSICI\u00d3N NEUTRAL)\n// ============================================================================\n// Cuando no hay comandos o se pierde la mano, los servos van a estos \u00e1ngulos\n// 90\u00b0 representa el centro del rango de movimiento\n\nconst int HOME_IZQ    = 90;   // Home servo izquierdo\nconst int HOME_ARRIBA = 90;   // Home servo central\nconst int HOME_DER    = 90;   // Home servo derecho\n\n// ============================================================================\n// CONFIGURACI\u00d3N PWM PARA SERVOS\n// ============================================================================\n// Los servos MG90S operan con se\u00f1ales PWM de 50Hz\n// El ancho del pulso determina la posici\u00f3n:\n// - ~1ms (5%) = 0\u00b0\n// - ~1.5ms (7.5%) = 90\u00b0\n// - ~2ms (10%) = 180\u00b0\n\nconst uint32_t FREQ_HZ   = 50;    // Frecuencia PWM: 50 Hz (per\u00edodo de 20ms)\nconst uint8_t  RES_BITS  = 12;    // Resoluci\u00f3n: 12 bits (0-4095)\nconst uint16_t DUTY_MIN  = 205;   // Duty cycle para 0\u00b0 (~1.0 ms)\nconst uint16_t DUTY_MAX  = 410;   // Duty cycle para 180\u00b0 (~2.0 ms)\n\n// ============================================================================\n// FUNCIONES DE CONVERSI\u00d3N DE \u00c1NGULOS\n// ============================================================================\n\n/**\n * Convierte grados (0-180) a valor de duty cycle para PWM\n *\n * @param deg \u00c1ngulo en grados (0-180)\n * @return Valor de duty cycle (205-410)\n *\n * La funci\u00f3n map() hace una interpolaci\u00f3n lineal:\n * 0\u00b0 -&gt; 205, 180\u00b0 -&gt; 410\n */\nuint16_t dutyFromDeg(int deg) {\n  deg = constrain(deg, 0, 180);                    // Limita al rango v\u00e1lido\n  return map(deg, 0, 180, DUTY_MIN, DUTY_MAX);     // Mapea a duty cycle\n}\n\n/**\n * Convierte \u00e1ngulo l\u00f3gico a f\u00edsico (inversi\u00f3n)\n *\n * @param logicalDeg \u00c1ngulo l\u00f3gico (0-180)\n * @return \u00c1ngulo f\u00edsico invertido (180-0)\n *\n * Esto es necesario porque los servos pueden estar montados\n * en direcci\u00f3n opuesta a la esperada. Invertir el \u00e1ngulo\n * hace que \"subir\" en el c\u00f3digo signifique \"subir\" f\u00edsicamente.\n */\nint logicalToPhysical(int logicalDeg) {\n  logicalDeg = constrain(logicalDeg, 0, 180);\n  return 180 - logicalDeg;  // Inversi\u00f3n: 0-&gt;180, 90-&gt;90, 180-&gt;0\n}\n\n/**\n * Escribe un \u00e1ngulo l\u00f3gico a un servo\n *\n * @param pin Pin GPIO del servo\n * @param logicalDeg \u00c1ngulo l\u00f3gico deseado (0-180)\n *\n * Convierte el \u00e1ngulo l\u00f3gico a f\u00edsico y luego a duty cycle\n * antes de escribir al pin PWM.\n */\nvoid writeServoLogical(int pin, int logicalDeg) {\n  int fisico = logicalToPhysical(logicalDeg);  // Convierte l\u00f3gico a f\u00edsico\n  ledcWrite(pin, dutyFromDeg(fisico));         // Escribe duty cycle al PWM\n}\n\n/**\n * Configura un pin GPIO como salida PWM para servo\n *\n * @param pin Pin GPIO a configurar\n * @param initialLogical \u00c1ngulo inicial en grados l\u00f3gicos\n *\n * En ESP32 Arduino Core 3.x, el pin act\u00faa como identificador del canal.\n * ledcAttach() configura autom\u00e1ticamente el canal PWM.\n */\nvoid configServo(int pin, int initialLogical) {\n  pinMode(pin, OUTPUT);                        // Configura pin como salida\n  ledcAttach(pin, FREQ_HZ, RES_BITS);          // Configura PWM: 50Hz, 12 bits\n  writeServoLogical(pin, initialLogical);      // Posiciona servo inicialmente\n}\n\n// ============================================================================\n// CONFIGURACI\u00d3N DE RAMPA (MOVIMIENTO SUAVE)\n// ============================================================================\n\nconst int  LIM_MIN     = 0;       // L\u00edmite m\u00ednimo de \u00e1ngulo\nconst int  LIM_MAX     = 180;     // L\u00edmite m\u00e1ximo de \u00e1ngulo\nconst int  PASO_RAMPA  = 5;       // Incremento por paso (grados)\nconst uint32_t DT_RAMP = 10;      // Intervalo entre pasos (ms)\nconst uint32_t TIMEOUT_MS = 700;  // Timeout para volver a home (ms)\n\n// ============================================================================\n// VARIABLES DE ESTADO\n// ============================================================================\n\n// Posiciones actuales de los servos (valores l\u00f3gicos)\nint posIzq    = HOME_IZQ;\nint posArriba = HOME_ARRIBA;\nint posDer    = HOME_DER;\n\n// Posiciones objetivo (hacia donde deben moverse)\nint tgtIzq    = HOME_IZQ;\nint tgtArriba = HOME_ARRIBA;\nint tgtDer    = HOME_DER;\n\n// Control de tiempo\nuint32_t tPrevRamp = 0;   // Timestamp del \u00faltimo paso de rampa\nuint32_t tLastCmd  = 0;   // Timestamp del \u00faltimo comando recibido\n\n// ============================================================================\n// FUNCI\u00d3N DE RAMPA SUAVE\n// ============================================================================\n/**\n * Aplica movimiento gradual hacia las posiciones objetivo\n *\n * Se ejecuta cada DT_RAMP milisegundos y mueve cada servo\n * un m\u00e1ximo de PASO_RAMPA grados hacia su objetivo.\n * Esto evita movimientos bruscos que podr\u00edan da\u00f1ar la mec\u00e1nica\n * o causar oscilaciones.\n */\nvoid aplicarRampa() {\n  uint32_t now = millis();\n\n  // Solo ejecuta si ha pasado suficiente tiempo\n  if (now - tPrevRamp &lt; DT_RAMP) return;\n  tPrevRamp = now;\n\n  // Lambda function para calcular siguiente posici\u00f3n\n  // Mueve hacia el target en pasos de PASO_RAMPA\n  auto go = [&amp;](int actual, int target) {\n    if (actual &lt; target) return min(actual + PASO_RAMPA, target);  // Subir\n    if (actual &gt; target) return max(actual - PASO_RAMPA, target);  // Bajar\n    return actual;  // Ya est\u00e1 en posici\u00f3n\n  };\n\n  // Actualiza posiciones actuales\n  posIzq    = go(posIzq,    tgtIzq);\n  posArriba = go(posArriba, tgtArriba);\n  posDer    = go(posDer,    tgtDer);\n\n  // Escribe las nuevas posiciones a los servos\n  writeServoLogical(SERVO_IZQ,    posIzq);\n  writeServoLogical(SERVO_ARRIBA, posArriba);\n  writeServoLogical(SERVO_DER,    posDer);\n}\n\n// ============================================================================\n// PARSER DE COMANDOS\n// ============================================================================\n/**\n * Parsea un mensaje de \u00e1ngulos en formato \"ANG:x,y,z\"\n *\n * @param msg Mensaje recibido (ej: \"ANG:45,90,135\")\n * @param aIzq Variable donde se guarda \u00e1ngulo izquierdo\n * @param aArriba Variable donde se guarda \u00e1ngulo central\n * @param aDer Variable donde se guarda \u00e1ngulo derecho\n * @return true si el parseo fue exitoso, false si el formato es inv\u00e1lido\n */\nbool parseAngulos(const String &amp;msg, int &amp;aIzq, int &amp;aArriba, int &amp;aDer) {\n  // Verifica que el mensaje comience con \"ANG:\"\n  if (!msg.startsWith(\"ANG:\")) return false;\n\n  // Extrae la parte de datos (despu\u00e9s de \"ANG:\")\n  String data = msg.substring(4);\n\n  // Busca las comas que separan los valores\n  int c1 = data.indexOf(',');          // Primera coma\n  int c2 = data.indexOf(',', c1 + 1);  // Segunda coma\n\n  // Verifica que existan ambas comas\n  if (c1 &lt; 0 || c2 &lt; 0) return false;\n\n  // Extrae y convierte cada valor\n  aIzq    = data.substring(0, c1).toInt();      // Primer n\u00famero\n  aArriba = data.substring(c1 + 1, c2).toInt(); // Segundo n\u00famero\n  aDer    = data.substring(c2 + 1).toInt();     // Tercer n\u00famero\n\n  return true;\n}\n\n// ============================================================================\n// FUNCI\u00d3N SETUP - INICIALIZACI\u00d3N\n// ============================================================================\n/**\n * Se ejecuta una vez al encender/reiniciar el ESP32\n * Configura la comunicaci\u00f3n serial, Bluetooth y los servos\n */\nvoid setup() {\n  // Inicializa comunicaci\u00f3n serial para debug (USB)\n  Serial.begin(115200);\n\n  // Inicializa Bluetooth con nombre visible \"ESP32-Stewart\"\n  SerialBT.begin(\"ESP32-Stewart\");\n\n  // Configura los 3 servos con sus posiciones home\n  configServo(SERVO_IZQ,    posIzq);\n  configServo(SERVO_ARRIBA, posArriba);\n  configServo(SERVO_DER,    posDer);\n\n  // Mensajes de informaci\u00f3n en Serial Monitor\n  Serial.println(\"ESP32 listo - Plataforma Stewart\");\n  Serial.println(\"Pines: 15 = Izq, 33 = Arriba, 25 = Der\");\n\n  // Inicializa timestamp del \u00faltimo comando\n  tLastCmd = millis();\n}\n\n// ============================================================================\n// FUNCI\u00d3N LOOP - BUCLE PRINCIPAL\n// ============================================================================\n/**\n * Se ejecuta continuamente despu\u00e9s del setup\n * Lee comandos Bluetooth, los procesa y actualiza los servos\n */\nvoid loop() {\n\n  // ========== LECTURA DE BLUETOOTH ==========\n  // Lee caracteres disponibles y los acumula en el buffer\n  while (SerialBT.available()) {\n    char c = (char)SerialBT.read();  // Lee un caracter\n\n    if (c == '\\n') {\n      // ----- FIN DE L\u00cdNEA: PROCESAR COMANDO -----\n      String msg = btBuffer;  // Copia el buffer\n      btBuffer = \"\";          // Limpia el buffer para el pr\u00f3ximo mensaje\n      msg.trim();             // Elimina espacios y saltos de l\u00ednea\n\n      if (msg.length() &gt; 0) {\n        tLastCmd = millis();  // Actualiza timestamp del \u00faltimo comando\n\n        // ----- COMANDO ZERO O LOST -----\n        // Enviados cuando se pierde la mano o se presiona 'z'\n        if (msg == \"ZERO\" || msg == \"LOST\") {\n          tgtIzq    = HOME_IZQ;\n          tgtArriba = HOME_ARRIBA;\n          tgtDer    = HOME_DER;\n          Serial.println(\"HOME ejecutado (ZERO/LOST)\");\n        }\n        // ----- COMANDO DE \u00c1NGULOS -----\n        else {\n          int aI, aA, aD;\n          if (parseAngulos(msg, aI, aA, aD)) {\n            // Parseo exitoso: actualiza objetivos con l\u00edmites\n            tgtIzq    = constrain(aI, LIM_MIN, LIM_MAX);\n            tgtArriba = constrain(aA, LIM_MIN, LIM_MAX);\n            tgtDer    = constrain(aD, LIM_MIN, LIM_MAX);\n            Serial.printf(\"ANG -&gt; %d, %d, %d\\n\", tgtIzq, tgtArriba, tgtDer);\n          }\n          else {\n            // Comando no reconocido\n            Serial.print(\"Comando desconocido: \");\n            Serial.println(msg);\n          }\n        }\n      }\n    }\n    else if (c != '\\r') {\n      // Acumula caracteres (ignora retorno de carro)\n      btBuffer += c;\n    }\n  }\n\n  // ========== TIMEOUT: RETORNO A HOME ==========\n  // Si no se reciben comandos por TIMEOUT_MS, vuelve a posici\u00f3n home\n  // Esto es una medida de seguridad por si se pierde la conexi\u00f3n\n  if (millis() - tLastCmd &gt; TIMEOUT_MS) {\n    tgtIzq    = HOME_IZQ;\n    tgtArriba = HOME_ARRIBA;\n    tgtDer    = HOME_DER;\n  }\n\n  // ========== APLICAR RAMPA ==========\n  // Mueve los servos suavemente hacia sus objetivos\n  aplicarRampa();\n  // Peque\u00f1o delay para estabilidad\n  delay(1);\n}\n</code></pre>"}]}